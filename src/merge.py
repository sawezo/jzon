"""
Merge atomic tables generated by 'breakdown.py'.

@author Samuel Zonay
"""


# standard
import re
from typing import TypeVar, Dict, Tuple, List

# variables
PandasDataFrame = TypeVar("pd.DataFrame")


# merging atomic tables
def check_if_tag_has_subtables(tag: str, tag2max_level: Dict[str, int]):
    """
    Skipping tables with subtables to avoid redundant merged outputs.
    """
    if any([tag + "<" in other_tag for other_tag in tag2max_level
            if tag != other_tag]):
        print(f"\u274C skipping {tag} since it has subtables")
        return True
    else:
        print(f"\n \u2705 creating table over chain '{tag}'")
        return False


def get_level_items(tag: str) -> Tuple[Dict[int, str], List[Tuple[str, str]]]:
    """
    Build level to feature chain tag respective to each level of the tag.
    """
    level2component = {int(c.split("_")[-1]): c for c in tag.split("<")}
    levels = [int(i) for i in list(level2component.keys())]

    level2feature = {level: "<".join([level2component[c_idx]
                                      for c_idx in range(level, -1, -1)][::-1])
                     for level in levels}

    levels = list(level2feature.keys())

    # pairing components in reversed order (so deepest is first)
    # don't need to merge root with itself so [:-1]
    paired_levels = list(zip(levels[::-1], levels[::-1][1:] + levels[:1]))[:-1]

    return level2feature, paired_levels


def get_downstream_table_tag(tag: str) -> str:
    """
    Get name of last table given table tag (excluding level info).
    """
    return "_".join(tag.split("<")[-1].split("_")[:-1])


def tidy_merge(
        child_tag: str,
        parent_tag: str,
        merged_df: PandasDataFrame) -> PandasDataFrame:
    """
    Post-process merged table.
    """
    # these key cols wont be present for consecutive levels since they are
    # dropped
    throwaway_key_cols = [c for c in ["PK", "PK_x",
                                      "PK_y", "FK_y"] if c in list(merged_df)]
    merged_df.drop(["_merge"] + throwaway_key_cols, axis=1, inplace=True)

    # tidying column names
    col2rename = dict()
    for indicator, tag in {"_x$": parent_tag, "_y$": child_tag}.items():
        cols_with_indicator = [c for c in list(merged_df)
                               if re.search(indicator, c) is not None]
        col2rename.update(dict(zip(cols_with_indicator,
                                   [tag + "." + c[:-2]  # leave off _x/_y
                                    for c in cols_with_indicator])))

    # drop the child primary key column (it was only needed for this merge)
    # the current parent primary key will be the foreign key in the next level
    col2rename["FK_x"] = "FK"
    merged_df.rename(col2rename, axis=1, inplace=True)

    return merged_df


def merge_level_pair(
        parent_df: PandasDataFrame,
        child_df: PandasDataFrame,
        parent_tag: str,
        child_tag: str) -> PandasDataFrame:
    """
    Perform a single merge for a dataframe and its child dataframe.
    """
    merged_df = parent_df.merge(child_df, left_on="PK", right_on="FK",
                                how="outer", indicator=True)

    # checking the merge was clean (everything in right should have linked to left)
    # not necesarily otherway around since some rows in parent table didn't
    # have child data)
    assert(dict(merged_df["_merge"].value_counts())["right_only"] == 0)

    return merged_df


def merge_tag_chain(tag: str,
                    table_tag2df: Dict[str,
                                       PandasDataFrame]) -> PandasDataFrame:
    """
    Merge multiple dataframes by following the component chain from right
    (deepest level) to left (root dataframe).
    """
    # building the feature chains up to this level for each item in the pair
    deepest = True
    level2feature, paired_levels = get_level_items(tag)
    for child__parent in paired_levels:
        child_feature, parent_feature = level2feature[child__parent[0]
                                                      ], level2feature[child__parent[1]]

        # additional tags to mark any columns duplicated over the two dfs
        child_tag = get_downstream_table_tag(level2feature[child__parent[0]])
        parent_tag = get_downstream_table_tag(level2feature[child__parent[1]])

        if deepest:
            child_df = table_tag2df[child_feature]
            deepest = False  # for next pass
        # else the child df is everything merged thus far

        # merging and tidying
        child_df = merge_level_pair(
            table_tag2df[parent_feature],
            child_df, parent_tag, child_tag)
        child_df = tidy_merge(child_tag, parent_tag, child_df)

    # don't need after merge through this level is done
    child_df.drop(["FK"], axis=1, inplace=True)
    return child_df  # the fully merged df when done iterating through all levels


def merge_tables(table_tag2df: Dict[str,
                                    PandasDataFrame]) -> Dict[str,
                                                              PandasDataFrame]:
    """
    Merge atomic tables together to create tables that exhaust all chains.
    """
    # looping through levels and tags per each level and building merged frames
    tag2max_level = {tag: len(tag.split("<")) - 1 for tag in table_tag2df}
    tag2df, deepest_level = dict(), max(tag2max_level.values())
    for level_idx in range(deepest_level, 0, -1):

        # for each tag at this level, if it doesn't have subtables it's the end
        # of a merge chain
        for tag in [tag for tag, level in tag2max_level.items()
                    if level == level_idx]:

            if check_if_tag_has_subtables(tag, tag2max_level):
                continue

            tag2df[tag] = merge_tag_chain(tag, table_tag2df)

    return tag2df
